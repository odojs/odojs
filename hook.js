// Generated by CoffeeScript 1.8.0
var Hook, compose, create, dom, extend, hook, widget;

create = require('virtual-dom/create-element');

compose = require('./compose');

widget = require('./widget');

extend = require('extend');

dom = require('virtual-dom/h');

Hook = (function() {
  function Hook(component, spec, state) {
    this.spec = spec;
    this.state = state;
  }

  Hook.prototype.type = 'Widget';

  Hook.prototype.init = function() {
    this.el = this.spec.render.call(this, this.state);
    dom = create(this.el);
    if (dom !== null) {
      this.el = dom;
    }
    setImmediate((function(_this) {
      return function() {
        _this.item = compose(_this.component, state, el);
        if (spec.enter != null) {
          return spec.enter.call(_this, _this.item, state);
        } else {
          return _this.item.mount();
        }
      };
    })(this));
    return this.el;
  };

  Hook.prototype.update = function(prev, el) {
    var k, result, v;
    for (k in prev) {
      v = prev[k];
      if (this[k] === void 0) {
        this[k] = v;
      }
    }
    result = el;
    if (this.spec.update != null) {
      result = this.spec.update.call(this, el, this.state, prev);
      if (result !== null) {
        dom = create(result);
        if (dom !== null) {
          result = dom;
        }
      }
    }
    if (this.spec.onUpdate != null) {
      this.spec.onUpdate.call(this, result, this.state, prev);
    }
    return result;
  };

  Hook.prototype.destroy = function(el) {
    if (this.spec.beforeUnmount != null) {
      return this.spec.beforeUnmount.call(this, el, this.state);
    }
  };

  return Hook;

})();

hook = function(spec) {
  var Component, hookSpec, plugin, _i, _len, _ref;
  spec = extend({}, spec);
  hookSpec = {
    render: function(state) {
      return dom('div');
    },
    afterMount: function(el, state) {
      this.item = compose(this.component, state, el);
      if (spec.enter != null) {
        return spec.enter.call(this, this.item, state);
      } else {
        return this.item.mount();
      }
    },
    onUpdate: function(el, state, prev) {
      var olditem;
      if (prev.component === this.component) {
        if (this.component == null) {
          return;
        }
        return this.item.update(state);
      }
      if (prev.component == null) {
        return this.spec.afterMount.call(this, el, state);
      }
      if (this.component == null) {
        return this.spec.beforeUnmount.call(this, el, state);
      }
      olditem = this.item;
      this.item = compose(this.component, state, el);
      if (spec.transition != null) {
        return spec.transition.call(this, olditem, this.item, state);
      } else {
        olditem.unmount();
        return this.item.mount();
      }
    },
    beforeUnmount: function(el, state) {
      if (spec.exit != null) {
        return spec.exit.call(this, this.item, state);
      } else {
        return this.item.unmount();
      }
    }
  };
  Component = function(component, state, options) {
    var result;
    result = new widget.Widget(hookSpec, state);
    result.component = component;
    result.options = options;
    result.hook = spec;
    return result;
  };
  Component.use = function(plugin) {
    return plugin(Component, spec);
  };
  _ref = hook.plugins;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    plugin = _ref[_i];
    Component.use(plugin);
  }
  return Component;
};

hook.plugins = [];

hook.use = function(plugin) {
  return hook.plugins.push(plugin);
};

module.exports = hook;
